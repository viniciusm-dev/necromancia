--[[
local creature = require("shared.creature")
creature.new()
]]--

local camera = require "orthographic.camera"

local CAMERA_ID = hash("/camera")
local CHARACTER = hash("/character")
local CREATURE = hash("/fungant")

local input = {
	left = hash("left"),
	right = hash("right"),
	up = hash("up"),
	down = hash("down")
}

local animation = {
	idle = hash("idle"),
	walking = hash("walking")
}

local spell = {}


local msg_contact_point_response = hash("contact_point_response")
local obstacle = hash("obstacle")

local move_speed = 70

function init(self)
	spell.casting = false
	spell.last_angle = 0
	msg.post(".", "acquire_input_focus")
	self.last_position = "right"
	self.velocity = vmath.vector3(0, 0, 0)
end

function get_angle(a, b, c)
	local ang = math.deg(math.atan2(c.y-b.y, c.x-b.x) - math.atan2(a.y-b.y, a.x-b.x))
	if ang < 0 then 
		return ang + 360
	else 
		return ang
	end
end

function cast_spell(initial_point, target_point, current_position)
	local new_angle = get_angle(initial_point, target_point, current_position)

	if spell.last_angle < new_angle then
		spell.last_angle = new_angle
	end

	print(spell.last_angle)
end

function update(self, dt)
	local current_position = go.get_position()
	current_position = current_position + self.velocity * dt
	
	go.set_position(current_position)

	self.velocity = vmath.vector3(0, 0, 0)
	
	local world_position = camera.world_to_screen(cam_id, go.get_world_position())
	local window_width, window_height = camera.get_window_size()
	if world_position.x < 0 or world_position.x > window_width or world_position.y < 0 or world_position.y > window_height then
		camera.follow(CAMERA_ID, CHARACTER,{ lerp = 0.5 })
	end

	if spell.casting then
		cast_spell(spell.initial, spell.target, go.get_world_position(CHARACTER))
	end
end

function on_message(self, message_id, message, sender)
	if message_id == msg_contact_point_response then
		local newpos = go.get_position() + message.normal * message.distance
		go.set_position(newpos)
	end
end

function animate(self, pressed, released)
	local direction = self.last_position ~= "right"
	if pressed then
		sprite.set_hflip("#sprite", direction)
		sprite.play_flipbook("#sprite", animation.walking)
	elseif released then
		sprite.play_flipbook("#sprite", animation.idle)
	end
end

function on_input(self, action_id, action)
	if action_id == input.left then
		self.last_position = "left"
		animate(self, action.pressed, action.released)
		self.velocity.x = self.velocity.x + (move_speed * -1)
	end
	if action_id == input.right then
		self.last_position = "right"
		animate(self, action.pressed, action.released, flip_horizontal)
		self.velocity.x = self.velocity.x + (move_speed * 1)
	end
	if action_id == input.up then
		animate(self, action.pressed, action.released, flip_horizontal)
		self.velocity.y = self.velocity.y + (move_speed * 1)
	end
	if action_id == input.down then
		animate(self, action.pressed, action.released, flip_horizontal)
		self.velocity.y = self.velocity.y + (move_speed * -1)
	end

	if action_id == hash("spell") then
		
		if action.pressed then
			if not spell.casting then 
				spell.initial = go.get_world_position(CHARACTER) 
				spell.target = go.get_world_position(CREATURE)
				spell.casting = true
			end
			
		elseif action.released then
			spell.casting = false
			spell.last_angle = 0
			print("spell canceled")
		end
	end
end